## Погружение в инкапсуляцию


### Данные экземпляра, методы экземпляра и свойства экземпляра

Начнем знакомство с принципом № 1 в ООП – «Инкапсуляция».

У лампочки есть состояние, есть выключатель, и мы не залезаем внутрь выключателя, чтобы понять как он работает.

Не нужно быть сам-себе режиссером – я сам пишу класс и сам его использую. 

НЕТ!
Класс пишет один человек, а использует его другой. И тот, который использует этот класс, не должен залезать внутрь класса (выключатель эти или телевизор), чтобы понять, что там внутри.

Представьте он на замок закрыт. 

Нам не должно быть интересно, как работает коробка передач автомобиля.

Не лезь – сломаешь

Типичный пример обращения напрямую к состоянию лампочки

```
lamp1.state
False
lamp1.state = True
lamp1.state
```

#### Понятие атрибута

Существует атрибуты у экземпляров класса и самого класс.
По порядку.

Мы дали напрямую обратиться к атрибуту экземпляра класса. 

Мы не должны были этого делать – давать доступ напрямую.

В джаве есть поля и свойства (вместо атрибутов). 

У нас в питоне атрибуты и свойства.

Атрибуты – непосредственно хранят эти свойства.

А свойства – это интерфейс доступа к этим значениям.

Как сделать интерфейс доступа к этим значениям. 

Как это делается в других языках?

Например в Джаве к каждому полю пишется свои методы get state и set state.

```python
def get_floor(self):
        return self.floor

    def set_state(self, f):
        self.state = f
```
Результат
```
lamp2.get_floor()
2
lamp2.set_floor(4)
lamp2.get_floor()
```

а если я снова сделаю ```lamp1.floor``` я снова получу доступ напрямую к ```floor```.

Для этих целей атрибут можно сделать приватным. 

Для этого использую ключевые слова, которых в пайтоне нет. 

Private, protected и public.

А в пайтоне – первое это конвенция, просто начать имя атрибута с подчеркивания.
```python
self._floor = floor
```

это чисто указатель, внутренняя кухня, конвенция.

Если мы хотим действительно сделать свойство закрытым от внешнего мира – физически невозможный доступ к атрибуту, название атрибута нужно начать с двух подчеркиваний. И здесь уже конкретная приватность. 

Теперь достучаться до floor из внешнего мира невозможно.

Из глобальной видимости его не видно. 


Теперь мы можем к нему обратиться с помощью методов … Однако это не удобно, каждый раз обращаться к функциям.

Поэтому в Пайтоне применяется трюк следующего содержания. Есть два способа, два варианта.

Делаем ```__state``` приватным. 

Пишем метод get_state. По задумке получать состояние можно, изменять состояние нет.

```python
    def get_state(self):
        return self.__state
```

и далее пишем переменную state (вне метода) и с помощью специальной функции property передаю функцию get_state которая должна выступать в роли геттера. 

```
    state = property(get_state)
```
Теперь можно получить состояние лампочки
```
print (lamp1.state)
```
а поменять состояние нельзя
```
lamp1.state = True
```

как это работает? 

При обращении к  lamp1.state в области видимости класса Lamp ищется метод с названием lamp и не находится, но находится переменная state которая через property вызывает функция get_state, которая возвращает состояние лампы.


Это не что иное, как интерфейс доступа. 

Т.е. атрибуте state  имеет атрибут доступа. Но пока у него есть возможность только получить данные. 

А теперь тоже самое сделаем с этажностью. 

Для этого приватим floor. 

Пишем свойство floor, обращаемся к функции property, внутри которой передаем сначала геттер, потом сеттер.

Теперь мы к нашей этажности имеем доступ как на чтение, так и на запись.

```python
def get_floor(self):
        return self.__floor

    def set_floor(self, f):
        self.__floor = f

    floor = property(get_floor, set_floor)
```
Результат:
```
lamp2.floor
2
lamp2.floor=4
lamp2.floor
```


У вас должен возникнуть вопрос.

В чем проблема, в чем задача, связанная с этим гетом и сетом.

Зачем я сделал state приватным. 

По правилам ООП напрямую обращаться к методам нельзя. В данном случае читать можно, изменять нельзя.

Зачем я сделал это с этажом и наградил его сеттером. 

Ответ и причина кроется в обратной совместимости. 

Когда мы ему даем прямой доступ, код от нас идет куда-туда, минуя нас, мы не можем перехватить, что посылается в атрибут состояния или в атрибут этажность. 

А если туда полетит какая-нибудь абракадабра.


А мы должны данные перехватывать, перед тем как они туда запишутся или уйдут оттуда.
Представьте себе, что-то сломалось или тз поменялось. 

Допустим этажность нужно писать русскими буквами

```
lamp1 = Lamp('один')
lamp2 = Lamp('ресепшен')
```
И тут мы получаем проблему, что новый код, должен писать кириллицу, а старый работает только с целочисленными этажами. 

А вдруг согласно ТЗ всё нужно писать в верхнем регистре.

Нам нужен в сеттере преобразователь. 

Т.е. перед тем как записать и отдать нам нужен какой-то код. 

Пример из жизни – Я хочу узнать как вас зовут. 

Я должен вам послать сообщение или спросить – как Вас зовут.

 Если я к вам обратился – вы ответите Иван Иванович, а если пацан на улице – вы ему Вано скажете, или там отправите его в Монино.

Т.е. если я очень хочу узнать ваше имя, я это не смогу сделать. 

Не давайте доступа без нужды. Не пишите на одежде как вас зовут.

Подводим итог по первому принципу ООП – инкапсуляция. 

В Пайтоне она реализована через _ и __ подчеркивания, а также функции property.

Свойства экземпляра класса: инкапсуляция.

Общий принцип реализации инкапсуляции.
(параллельно создать еще python-файл, класс c Lamp оставить без изменения).

```python
class Класс:

    def __init__(self, значение = 0):
        # нет доступа по соглашению
        self._protected = значение
        # конкретно нет доступа
        self.__private = значение

    def get_private(self):
        return self.__private

    def set_private(self, value):
        self.__private = value

    private = property(get_private, set_private)


объект = Класс()
объект.private = 100

print(объект.private)
```

Пишем ```объект.private = 100```. 

Ищем его в области видимости методов, потом атрибутов, и находим, а далее через property 
```python
объект = Класс()
объект.private = 100

print(объект.private)

```

Есть еще вторая возможность. Использовать декораторы для свойств.
```python
class Класс:

    def __init__(self, значение = 0):
        self.__private = значение
    # getter
    @property
    def private(self):
        return self.__private

    # setter
    @private.setter
    def private(self, value):
        self.__private = value
```


Они используются вот таким образом. 

Предположим, что у меня есть атрибут private и я хочу описать для него геттер и сеттер.

Геттер описывается через декоратор property и описываем соответственно, метод с именем, который будет дергаться (вызываться).

Чтобы описать сеттер, декоратор становится именем свойства. @private (имя свойства) точка setter. 
Таким образом мы имеем два метода с одинаковым именем.

Еще раз посмотрим на код и зафиксируем синтаксис инкапсуляции в Пайтон с помощью декоратора property и имя_свойства.setter.
```python
   @property
    def state(self):
        return self.__state

    @state.setter
    def state(self, s):
        self.__state = s
```
Результат:

```
print (lamp2)
lamp1.state = 6
print (lamp1.state)
lamp1.floor = 2
print (lamp2)
```

Это все встроенное в Пайтон. 


Соглашения, конвенция, дзен, философия. Синтаксический сахар.

Однако, мы всё пока крутится вокруг объекта класса, т.е сущности которые класс порождает – лампочки, породы собак, модели автомобилей.

Но в пайтоне все является объектом и даже класс. Поэтому мы можем смело создать атрибуты у самого Класс.

Атрибут класса

```python
class ИмяКласса:
    атрибут_класса = значение_по_умолчанию

    def метод(self, параметр):
        ИмяКласса.атрибут_класса = параметр
```

 
Т.е. они указываются прямо в классе. В чем фича? 

Атрибут общий для всех порождаемых классом сущностей.
У человека – две руки, у автомобиля – есть кузов, двигатель. Или константа pi, e или число Авогадро.
Или у всех ламочек бренд “Филипс”

```python
class Lamp:
    brand = "Philips"
Если мы обращаемся извне, то мы пишем имя класса и атрибут:

объект = ИмяКласса()
объект.метод(значение)

print(ИмяКласса.атрибут_класса)

print(lamp2.brand)
```

а конструкторе (инициализаторе) прописать

```python
  def __init__(self, floor=0):
        self.__state = False
        self.__floor = floor
        print(f'Создана лампочка {Lamp.brand}' )
```

?Оно не принадлежит объекту? Оно унаследовано от …
Для чего еще могу быть использованы атрибуты класс. К примеру, для подсчета общего количества лампочек

```python
class Lamp:
    brand = "Philips"
    count = 0
    def __init__(self, floor=0):
        self.__state = False
        self.__floor = floor
        Lamp.count +=1
        print(f'Создана лампочка {Lamp.brand} № {Lamp.count}' )
```

Результат
```
Создана лампочка Philips № 1
Создана лампочка Philips № 2
Создана лампочка Philips № 3

print(f'Всего лампочек - {Lamp.count}')
Всего лампочек – 3

```

Это довольно удобно.

Кроме того, у класса могут быть не только методы, но и методы. Не что иное как поведение класса.
Причем, у нас есть две возможности – статический и классический (класс) методы.

Классные методы (методы класса)

```python
class ИмяКласса:
    атрибут_класса = 0
    @staticmethod
    def static_method():
        return ИмяКласса.атрибут_класса

    @classmethod
    def class_method(cls):
        return cls.атрибут_класса

объект = ИмяКласса()

объект.static_method()
объект.class_method()
```

Технический между ними разницы нет.  Есть синтаксическая разница. Если мы используем декоратор @staticmethod то обращение идет к классу через точку его метод.

```python
@staticmethod
    def static_method():
        return Lamp.count

    @classmethod
    def class_method(cls):
        return cls.count


print (lamp1.static_method())
print (lamp1.class_method())
```


Если используем класс-метод (в терминах ООП – это тоже классический метод). 

Но в класс-методе, декоратор автоматом передает имя класс. 

Некая переменная в которую прилетает имя класса, по соглашению, по конвенции – название её  cls ( по аналогии self).

В первом случае имя класс мы пишем руками. 

Никакого self. Но какая возникает проблема. 

Подумайте, если мы поменяем имя класса. Что это значит? 

Нам нужно будет поменять имя класса во всех статических методах.

В случае с класс-методами – этого делать не нужно. 

Разница в терминах ООП никакой. Кроме того, что необходимо менять название в статик-методах.

Ну и, соответственно, внутри класса мы не можем обращаться к каким-либо объектам. Только к классу. 

К общему поведению всех объектов. Т.е класс – это тоже самостоятельная единица.

