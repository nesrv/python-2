# Модуль 1. Понятие класса. Инкапсуляция  (4 ак. ч.)

### План

*	Класс и экземпляр класса.
*	Данные экземпляра, методы экземпляра и свойства экземпляра.
*	Понятие атрибута.
*	Практикум: Создание класса и его экземпляров.



## Введение

### 1. Что такое ООП?

- Программирование, построенное на классах
- Инструмент стратегического планирования
- Программная единица пакетирования логики и данных

### 2. Что такое класс?

- Пакет функций
- Главный инструмент ООП
- Оснащение, отражающее реальные объекты в программе
- Фабрика производства экземпляров

### 3. Принципы (аспекты) ООП

- Наследование
- Композиция

### Механизм ООП в Python - 2 порции магии

- Первый аргумент self
- Поиск в иерархии наследования

## Резюме

- Всё остальное в ООП сводится к функциям
- Не являясь радикально новым, ООП добавляет дополнительный уровень структуры, которая поддерживает
  более эффективное программирование, чем обычные процедурные модели.
- Наряду с рассмотренными ранее функциональными инструментами ООП олицетворяет собой значительный шаг в сторону абстрагирования от компьютерного оборудования, который помогает нам строить более сложно устроенные программы.

## Продолжение введения

- ООП в Python гораздо проще для понимания и использования, чем в других языках, таких как C++ или Java.
- Будучи динамически типизированным языком написания сценариев, Python устраняет большую часть синтаксического беспорядка и сложности, которые затуманивают ООП в других инструментах.
- На самом деле большинство истории ООП в Python сводится до следующего выражения:

```python
объект.атрибут
```

**Классы**

Служат фабриками экземпляров. Атрибуты классов обеспечивают поведение (данные и функции), которое наследуется всеми экземплярами, сгенерированными из них (например, функция для расчета заработной платы сотрудника на основе оклада и отработанных часов).

**Экземпляры**

Представляют конкретные элементы в предметной области программы.
Атрибуты экземпляров хранят данные, которые варьируются для каждого отдельного объекта (скажем, номер карточки социального страхования сотрудника).

```
С точки зрения деревьев поиска экземпляр наследует атрибуты от своего класса, а класс наследует атрибуты от всех классов выше в дереве.
```

- Хотя формально классы и экземпляры, помещаемые в деревья наследования, являются разными типами объектов в модели Python, они практически идентичны;

- Главная цель каждого типа заключается в том, чтобы служить еще одним видом пространства имен — пакета переменных и места, куда мы можем присоединять атрибуты.

- Таким образом, если классы и экземпляры выглядят подобными модулям, то так и должно быть;

- Но, тем не менее, объекты в деревьях классов также имеют автоматически просматриваемые ссылки на другие объекты пространств имен и классы соответствуют операторам, а не целым файлам.

## Резюме

- Основное отличие между классами и экземплярами состоит в том, что классы представляют собой своего рода фабрики ддя генерирования экземпляров.

- Второе отличие между классами и модулями — мы можем иметь только один экземпляр отдельного модуля в памяти (именно потому модуль приходится перезагружать, чтобы получить его новый код), но для классов допускается создавать столько экземпляров, сколько нужно.

## Трансформация мышления


### Исходное ТЗ

Программа: чтение с клавиатуры; 
вывод в терминал.



```python
def process():
  msg = input('Введите что-нибудь: ')
  print(msg)

process()
```

### Изменения-1 в ТЗ

Добавить: чтение из файла

```python
def file_read():
    return "Зачитали файл"


def process(from_file=False):
    if from_file:
        msg = file_read()
    else:  
        msg = input('Введите что-нибудь: ')
    print(msg)

process()
process(True)
```

### Изменения-2 в ТЗ
Добавлить: отправить данные по сети.

```python
def file_read():
    return "Зачитали файл"

def from_terminal():
    return input('Введите что-нибудь: ')

def to_terminal(msg):
    print(f'Послали в терминал: {msg}')

def send_message(msg):
    print(f"Послали по сети: {msg}")

def process(from_file=False, send_to=False):
    if from_file:
        msg = file_read()
    else:
        msg = from_terminal()
        if send_to:
            send_message(msg)
        else:
            to_terminal(msg)

process()
process(True)
process(True, True)
process(False, True)
```

#### ВЫВОДЫ:

* Грязно
* Много условных выражений
* Сложно поддерживать
* Сложно понять


### Вывод – нас спасет ООП
