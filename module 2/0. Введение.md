## Погружение в инкапсуляцию


## Модуль 2. Наследование  (4 ак. ч.)
* Принцип утиной типизации.
* Понятия базового класса и производного класса.
* Функция isinstance и ее применение.
* Практикум: Создание производного класса, применение экземпляров базового и производного класса.

### Утиная типизация
Часто, когда речь заходит о Python, всплывает фраза утиная типизация, или даже что-нибудь вроде:

> Если это выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка

Утиная типизация – это концепция, характерная для языков программирования с динамической типизацией, согласно которой конкретный тип или класс объекта не важен, а важны лишь свойства и методы, которыми этот объект обладает. 

Другими словами, при работе с объектом его тип не проверяется, вместо этого проверяются свойства и методы этого объекта.

Такой подход добавляет гибкости коду, позволяет полиморфно работать с объектами, которые никак не связаны друг с другом и могут быть объектами разных классов. 

Единственное условие, чтобы все эти объекты поддерживали необходимый набор свойств и методов.

```python
class Meter:
    def __len__(self):
        return 1_000

len([1, 2, 3])

len("Duck typing...")

print(len(Meter()))
```


В примере выше функции len не важен тип аргумента, а важно лишь то, что у объекта можно вызвать метод `__len__()`.

Но именно эта гибкость и усложняет раннее обнаружение ошибок типизации. Корректность использования объектов определяется динамически, в момент выполнения программы, и зачастую тестирование – единственный способ отловить подобные ошибки. 

Статическая проверка типов и корректности программы в данном случае представляет значительную сложность.

`
Утиная типизация заключается в том, что вместо проверки типа чего-либо в Python мы склонны проверять, какое поведение оно поддерживает, зачастую пытаясь использовать это поведение и перехватывая исключение, если оно не работает.
`

Python программисты говорят "если это похоже на утку и крякает как утка, то это утка". Не нужно проверять ДНК утки, чтобы понять утка ли это, нужно просто посмотреть на ее поведение.

Утиная типизация "DuckTyping" настолько глубоко заложена и распространена в Python, что она действительно повсюду, как вода для рыбы: мы даже не думаем об этом. В Python очень часто проще предположить поведение объектов, вместо проверки их типов.

Идея утиной типизации 'Duck Typing' в языке программирования Python повсеместна.

Встроенная функция sum() принимает любые повторяющиеся объекты, которые она может сложить вместе. То есть она работает со всем, что поддерживает знак '+', даже со списками и кортежами:

> sum([(1, 2), (3, 4)], ())

Встроенные функции zip и enumerate принимают любые iterable - итерируемые объекты. Не только list или sequence, любые iterable!

> list(zip([1, 2, 3], (4, 5, 6), range(3)))