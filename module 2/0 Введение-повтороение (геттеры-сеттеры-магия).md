## Геттеры-сеттеры. Магия 

## Повторение 
```python
class SuperPoint:
    '''суперкласс'''

class Point(SuperPoint):
    ''' аннотация'''
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f'Точка ({self.x},{self.y})'

p1 = Point(2, 7)
p2 = Point(12, 7)


print(Point.__dict__) # '__module__': 

print(p1.__dict__) # {'x': 2, 'y': 7}
print(p1.__doc__) #  аннотация
print(Point.__name__) # Point
print(p1.__class__.__name__) # Point
print(Point.__base__) # <class 'object'>


print(Point.mro()) #<class '__main__.Point'>, <class '__main__.SuperPoint'>, <class 'object'>
print(issubclass(Point, SuperPoint))
print(issubclass(Point, object))
print(issubclass(list, object))
print(isinstance(Point, object))
print(isinstance(p1, object))
print(dir(Point))
```

```python
class Point:
   def __init__(self, x, y):
       self.__x = x
       self.__y = y
```

## Геттеры-сеттеры - 5 способов

### способ № 1. Типовой

```python
def get_coords(self):
     return self.__x, self.__y

def set_coords(self, x, y):
     self.__x = x
     self.__y = y


A = Point(1, 2)
print(A.get_coords())
print(A.get_coords())

A.set_coords(3, 4)
print(A.get_coords())
```

### способ № 2. Через функцию property

```python
def get_coords(self):
  return self.__x, self.__y

def set_coords(self, x, y):
    self.__x = x
    self.__y = y


coords = property(get_coords, set_coords)

A = Point(1, 2)

print(A.coords)

```

### способ № 3 Через декоратор @property

```python
@property
 def x(self):
    return self.__x
@x.setter
def x(self, x):
       self.__x = x

A = Point(1, 2)
A.x = 5
print(A.x)

```

### способ № 4* Через dataclass (ОО дизайн)

Также мы должны познакомиться с относительно новой идеей «быстрого» описания классов (классов данных – `Data Classes`). 

О чем здесь речь? Смотрите, довольно часто при объявлении классов в программах на `Python` приходится прописывать инициализатор, например, следующим образом:

```python
class Thing:
    def __init__(self, name, weight, price):
        self.name = name
        self.weight = weight
        self.price = price
```

То есть, передается несколько полей: `name, weight, price`, которые предполагается сохранять в объектах класса `Thing`. 
И это довольно типовая ситуация. Мало того, если создать объект этого класса и вывести его в консоль:

```python
t = Thing("Учебник по Python", 100, 1024)
print(t)
```
то увидим нечто неинформативное, вроде:

> <__main__.Thing object at 0x0000014B7D29A7D0>

Поэтому, опять же нередко, в таких классах с данными приходится прописывать магический метод `__repr__()`, например, так:

```python
    def __repr__(self):
        return f"Thing: {self.__dict__}"
```


Видите, сколько типовой писанины приходится делать для описания классов, подобных классу `Thing?`! 

И это лишь необходимый минимум. 
Представьте объем рутиной работы для описания всего лишь нескольких таких классов.

Так как программист, зачастую, существо глубоко ленивое, но творческое, уже давно предпринимались попытки автоматизировать этот процесс. 

И вот, начиная с версии Python 3.7, появилась возможность «из коробки» использовать инструмент для оптимизации объявления классов, содержащих произвольные данные, то есть,  `Data Classes`. 

Для этого, в самом простом варианте, достаточно импортировать специальный декоратор, который так и называется `dataclass`:

```python
from dataclasses import dataclass

@dataclass
class Point:
      x: int
      y: int

def __post_init__(self):
    print(self.x,self.y)
    self.length = (self.x ** 2 + self.y ** 2) ** 0.5
```


### Способ № 5 Патерн моносостояние (ОО дизайн)

Рассмотрим реализацию паттерна «Моносостояние», реализуемое на уровне классов и объектов. 
На примере этого паттерна в Python можно легко и гибко управлять локальными атрибутами экземпляров класса.

![](img/mono_state.png)

Вначале разберем саму идею «Моносостояния». 
Представьте, что у нас некий многопоточный процесс и в каждом потоке создается свой экземпляр класса ThreadData. Но нам бы хотелось, чтобы все они имели единые локальные свойства:

```python
class Point:
    coords = {
        'x' : 10,
        'y' : 20
    }

    def __init__(self):
        self.__dict__ = self.coords
```

