## Перегрузка магических методов 

### 1. Точка на плоскости

Написать класс PointXY, у которого есть атрибуты x и y. Пример:

```python
# Без конструктора
p0 = PointXY()
p4 = PointXY()
p0.x = 1
p0.y = 5
p4.x = 8
p4.y = 7

# С конструктором:
p1 = PointXY(1, 3)
p2 = PointXY(4, 5)
```

Сделать методы

а) расстояние от начала координат до этой точки

``` python
d0 = p0.distance_from_zero()
```

б) расстояние от точки до другой точки

``` python
d = p0.distance_to(p4)
```

Забыли геометрию?
Расстояние от нуля:
![\Large \sqrt{x^{2}+y^{2}}](https://latex.codecogs.com/svg.latex?\Large&space;\sqrt{x^{2}+y^{2}})

Расстояние между двумя точками
![\Large \sqrt{{(x_{1}-x_{2})}^{2}+{(y_{1}-y_{2})}^{2}}](https://latex.codecogs.com/svg.latex?\Large&space;\sqrt{{(x_{1}-x_{2})}^{2}+{(y_{1}-y_{2})}^{2}})


в) Дополнить класс PointXY, чтобы можно было указывать координаты при создании


``` python
class PointXY:
    def __init__(self, ...):
        # ...

# ...

p1 = PointXY(3, 4)
```

г) Добавить функции сравнения двух точек == != с помощью методов [```__eq__()```, ```__ne__()```](https://docs.python.org/3/reference/datamodel.html#object.__lt__)

```python
print(p1 == p2)
print(p1 != p2)
```

д) Добавить арифметические функции. Сложение точек - как векторная сумма (сумма иксов и игреков) [```__add__()```](https://docs.python.org/3/reference/datamodel.html#object.__add__). Умножение точки на число - x и y умножаются на это число, функция ```__mul__()```. 
Все арифметические функции будут создавать новый объект типа ```PointXY```.

```python
p3 = p1 + p2
p4 = p1 * 0.5
```

г) Унарные операции [```__neg__(), __invert__()```](https://docs.python.org/3/reference/datamodel.html#object.__neg__) - пусть дают новую точку, у которой x и y с противоположным знаком. Также можно сделать ```___abs___()```, пусть это будет длина вектора.

```python
p1 = -p2
p1 = ~p2
print(abs(p1))
```


<details>
<summary>Подсказка</summary>

```python
class PointXY:
    def __init__(self, x=0, y=0):
        self.x = x
        self.y = y

    def distance_from_zero(self):
        return (self.x ** 2 + self.y ** 2) ** 0.5

    def distance_from_to(self, point):
        return ((self.x - point.x) ** 2 + (self.y - point.y) ** 2) ** 0.5

    def __str__(self):
        return f'Точка с координатами x={self.x},y={self.y} '

    def __eq__(self, other):
        return self.x == other.x and self.y == other.y


p1 = PointXY(4, 3)
p3 = PointXY(4, 3)
p2 = PointXY(-4, -3)

d1_0 = p1.distance_from_zero()
print(d1_0)

d2_0 = p1.distance_from_zero()
print(d2_0)

d1_2 = p1.distance_from_to(p2)
print(d1_2)
print(p1 == p3)

```
</details>


### 2. Известно, что в Python мы можем соединять два списка между собой с помощью оператора +:
```python
lst = [1, 2, 3] + [4.5, -3.6, 0.78]
```
Но нет реализации оператора -, который бы убирал из списка соответствующие значения вычитаемого списка, как это показано в примере:
```python
lst = [1, 2, 3, 4, 5, 6] - [5, 6, 7, 8, 1] # [2, 3, 4] (порядок следования оставшихся элементов списка должен сохраняться)
```

Давайте это поправим и создадим такой функционал. Для этого нужно объявить класс с именем NewList, объекты которого создаются командами:
```python
lst = NewList() # пустой список
lst = NewList([-1, 0, 7.56, True]) # список с начальными значениями
```
Реализуйте для этого класса работу с оператором вычитания, чтобы над объектами класса NewList можно было выполнять следующие действия:

```python
lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
lst2 = NewList([0, 1, 2, 3, True])
res_1 = lst1 - lst2 # NewList: [-4, 6, 10, 11, 15, False]
lst1 -= lst2 # NewList: [-4, 6, 10, 11, 15, False]
res_2 = lst2 - [0, True] # NewList: [1, 2, 3]
res_3 = [1, 2, 3, 4.5] - res_2 # NewList: [4.5]
a = NewList([2, 3])
res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
```
Также в классе NewList необходимо объявить метод:

> get_list() - для возвращения результирующего списка объекта класса NewList

Например:

> lst = res_2.get_list() # [1, 2, 3]



<details>
<summary>Подсказка</summary>

```python
class NewList:

    def __init__(self, lst=[]):
        self.lst = lst

    def __str__(self):
        return str(self.lst)

    def get_list(self):
        return self.lst

    def __sub__(self, other):
        lst_1 = self.lst
        lst_2 = other if type(other) == list else other.get_list()
        lst_1 = NewList.__sub_list(lst_1, lst_2)
        return NewList(lst_1)

    def __rsub__(self, other):
        return NewList(other) - self.lst

    @staticmethod
    def __sub_list(lst_1, lst_2):
        lst_1 = [(x, type(x)) for x in lst_1]
        lst_2 = [(x, type(x)) for x in lst_2]
        for x in lst_2:
            if x in lst_1:
                lst_1.remove(x)
        lst_1 = [x[0] for x in lst_1]
        return lst_1


# lst = NewList()
# lst = NewList([-1, 0, 7.56, True])
# print(lst)

lst1 = NewList([1, 2, -4, 6, 10, 11, 15, False, True])
lst2 = NewList([0, 1, 2, 3, True])
res_1 = lst1 - lst2  # NewList: [-4, 6, 10, 11, 15, False]
print(res_1)
lst1 -= lst2  # NewList: [-4, 6, 10, 11, 15, False]
print(lst1)
res_2 = lst2 - [0, True]  # NewList: [1, 2, 3]
print(res_2)

res_3 = [1, 2, 3, 4.5] - res_2  # NewList: [4.5]
print (res_3)
a = NewList([2, 3])
res_4 = [1, 2, 2, 3] - a # NewList: [1, 2]
print(res_4)
```
</details>