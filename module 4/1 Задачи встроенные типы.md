### Пример
Что нам мешает наследоваться от базовых классов и расширять функционал по мере необходимости? Ничего, поэтому можно сделать, например, такую реализацию:

```python
class Vector(list):
    def __str__(self):
        return " ".join(map(str, self))
 
 
v = Vector([1, 2, 3])
print(v)
```

Мы здесь переопределили магический метод `__str__` для вывода списка в виде набора данных через пробел. Мало того, теперь тип данных нашего списка стал не list, а Vector:
```
print(type(v))
```

### Задача 1. Как переопределить метод append, реализовав в нем не добавление элементов, как по умолчанию, а удаление последнего элемента.

```python
 def append(self):
  ...
```

### Задача 2. Добавить метод append_first, реализовав в нем добавление элементов в начало списка.

### Задача 3.Разрешить сложение списка со строкой и наоборот

``` python
v1 = v + 'python'
print (v1) # 1,2,p,y,t,h,o,n
v2 = 'python' + v # p,y,t,h,o,n,1,2
print(v2)

```


## Задача 4. Известно, что с объектами класса `tuple` можно складывать только такие же объекты (кортежи). 

Например:

```python
t1 = (1, 2, 3)
t2 = t1 + (4, 5) # (1, 2, 3, 4, 5)
```

Если же мы попытаемся прибавить любой другой итерируемый объект, например, список:

```python
t2 = t1 + [4, 5]
```
то возникнет ошибка. 

Предлагается поправить этот функционал и создать свой собственный класс `Tuple`, унаследованный от базового класса `tuple` и поддерживающий оператор:

```python
t1 = Tuple(iter_obj)
t2 = t1 + iter_obj  # создается новый объект класса Tuple с новым (соединенным) набором данных
```

где `iter_obj` - любой итерируемый объект (список, словарь, строка, множество, кортеж и т.п.)

Пример использования класса:

```python
t = Tuple([1, 2, 3])
t = t + "Python"
print(t)   # (1, 2, 3, 'P', 'y', 't', 'h', 'o', 'n')
t = (t + "Python") + "ООП"
print (t) # (1, 2, 3, 'P', 'y', 't', 'h', 'o', 'n', 'P', 'y', 't', 'h', 'o', 'n', 'О', 'О', 'П')
```


### Задача 5. Объявите класс StringDigit, который наследуется от стандартного класса str. 

Объекты класса `StringDigit` должны создаваться командой:

```python
sd = StringDigit(string)
```
где `string` - строка из цифр (например, "12455752345950"). 

Если в строке `string` окажется хотя бы один не цифровой символ, то генерировать исключение командой:

```python
raise ValueError("в строке должны быть только цифры")
```
Также в классе `StringDigit` нужно переопределить оператор + (конкатенации строк) так, чтобы операции:

```python
sd = sd + "123"
sd = "123" + sd
```
создавали новые объекты класса `StringDigit` (а не класса `str`). 

Если же при соединении строк появляется не цифровой символ, то генерировать исключение:

```python
raise ValueError("в строке должны быть только цифры")
```
Пример использования класса :

```python
sd = StringDigit("123")
print(sd)       # 123
sd = sd + "456" # StringDigit: 123456
sd = "789" + sd # StringDigit: 789123456
sd = sd + "12f" # ValueError
```